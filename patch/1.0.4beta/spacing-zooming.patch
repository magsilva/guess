### Eclipse Workspace Patch 1.0
#P guess-cvs
Index: src/edu/umd/cs/piccolox/handles/GuessPHandle.java
===================================================================
RCS file: /cvsroot/guess/guess/src/edu/umd/cs/piccolox/handles/GuessPHandle.java,v
retrieving revision 1.1
diff -u -r1.1 GuessPHandle.java
--- src/edu/umd/cs/piccolox/handles/GuessPHandle.java	5 Oct 2005 20:19:55 -0000	1.1
+++ src/edu/umd/cs/piccolox/handles/GuessPHandle.java	17 Oct 2008 14:46:34 -0000
@@ -1,11 +1,15 @@
 package edu.umd.cs.piccolox.handles;
 
+import java.awt.BasicStroke;
+
 import java.awt.Cursor;
 import java.awt.geom.Point2D;
 import java.util.ArrayList;
 import java.util.Iterator;
 
 import javax.swing.SwingConstants;
+import com.hp.hpl.guess.Guess;
+import com.hp.hpl.guess.piccolo.util.PFixedWidthStroke;
 
 import edu.umd.cs.piccolo.PCamera;
 import edu.umd.cs.piccolo.PNode;
@@ -47,7 +51,12 @@
     }
 						    
     public GuessPHandle(PBoundsLocator aLocator) {
-	super(aLocator);
+		super(aLocator);
+	    if (Guess.getZooming() == Guess.ZOOMING_SPACE) {
+	    	setStroke(new PFixedWidthStroke(0.5f));
+	    } else {
+	    	setStroke(new BasicStroke(0.5f));
+	    }
     }
     
     public void startHandleDrag(Point2D aLocalPoint, PInputEvent aEvent) {
Index: src/com/hp/hpl/guess/ui/FrameListener.java
===================================================================
RCS file: /cvsroot/guess/guess/src/com/hp/hpl/guess/ui/FrameListener.java,v
retrieving revision 1.1
diff -u -r1.1 FrameListener.java
--- src/com/hp/hpl/guess/ui/FrameListener.java	5 Oct 2005 20:19:51 -0000	1.1
+++ src/com/hp/hpl/guess/ui/FrameListener.java	17 Oct 2008 14:46:32 -0000
@@ -104,6 +104,6 @@
      * @pyexport
      */
     public void removeBackgroundImage();
-
+    
     public BufferedImage getFullImage();
 }
Index: src/com/hp/hpl/guess/ui/GMenuBar.java
===================================================================
RCS file: /cvsroot/guess/guess/src/com/hp/hpl/guess/ui/GMenuBar.java,v
retrieving revision 1.9
diff -u -r1.9 GMenuBar.java
--- src/com/hp/hpl/guess/ui/GMenuBar.java	30 Sep 2008 11:29:18 -0000	1.9
+++ src/com/hp/hpl/guess/ui/GMenuBar.java	17 Oct 2008 14:46:34 -0000
@@ -132,6 +132,47 @@
 	 * Create the menu view
 	 */
 	private void buildViewMenu() {
+
+		JMenuItem centerMenuItem = new JMenuItem("Center");
+		centerMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F5, 0, false));
+		centerMenuItem.setMnemonic('c');
+		viewMenu.add(centerMenuItem);
+		viewMenu.addSeparator();
+		
+		JCheckBoxMenuItem informationWindowMenuItem = new JCheckBoxMenuItem("Information Window");
+		informationWindowMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F4, 0, false));
+		informationWindowMenuItem.setMnemonic('i');
+		informationWindowMenuItem.setState(userPrefs.getBoolean("openInformationWindow", false));
+		viewMenu.add(informationWindowMenuItem);
+
+		JCheckBoxMenuItem consoleMenuItem = new JCheckBoxMenuItem("Console");
+		consoleMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F12, 0, false));
+		consoleMenuItem.setState(userPrefs.getBoolean("openConsole", true));
+		consoleMenuItem.setMnemonic('o');
+		if (Guess.guiMode) { // use internal console
+		viewMenu.add(consoleMenuItem);
+		}
+		viewMenu.addSeparator();		
+		
+		final JRadioButtonMenuItem zoomZoomMenuItem = new JRadioButtonMenuItem("Zoom");
+		zoomZoomMenuItem.setSelected(Guess.getZooming()==Guess.ZOOMING_ZOOM);
+		zoomZoomMenuItem.setMnemonic('z');
+		zoomZoomMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F7, 0, false));
+		viewMenu.add(zoomZoomMenuItem);
+		
+		final JRadioButtonMenuItem zoomSpaceMenuItem = new JRadioButtonMenuItem("Space");
+		zoomSpaceMenuItem.setSelected(Guess.getZooming()==Guess.ZOOMING_SPACE);
+		zoomSpaceMenuItem.setMnemonic('p');
+		zoomSpaceMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F8, 0, false));
+		viewMenu.add(zoomSpaceMenuItem);
+		viewMenu.addSeparator();
+		
+		JCheckBoxMenuItem fullscreenMenuItem = new JCheckBoxMenuItem("Fullscreen");
+		fullscreenMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F11, 0, false));
+		fullscreenMenuItem.setMnemonic('f');
+		fullscreenMenuItem.setState(userPrefs.getBoolean("openFullscreen", false));
+		viewMenu.add(fullscreenMenuItem);	
+
 		ActionListener viewListener = new ActionListener() {
 			public void actionPerformed(ActionEvent event) {
 				if (event.getActionCommand().equals("Center")) {
@@ -162,40 +203,24 @@
 					JCheckBoxMenuItem fullscreen = (JCheckBoxMenuItem) event.getSource();
 					Guess.getMainUIWindow().setFullScreenMode(fullscreen.getState());
 					userPrefs.putBoolean("openFullscreen", fullscreen.getState());
+				} else if (event.getActionCommand().equals("Zoom")) {
+					Guess.setZooming(Guess.ZOOMING_ZOOM);
+					zoomZoomMenuItem.setSelected(Guess.getZooming()==Guess.ZOOMING_ZOOM);
+					zoomSpaceMenuItem.setSelected(Guess.getZooming()==Guess.ZOOMING_SPACE);
+				} else if (event.getActionCommand().equals("Space")) {
+					Guess.setZooming(Guess.ZOOMING_SPACE);
+					zoomZoomMenuItem.setSelected(Guess.getZooming()==Guess.ZOOMING_ZOOM);
+					zoomSpaceMenuItem.setSelected(Guess.getZooming()==Guess.ZOOMING_SPACE);					
 				}
 			}
 		};
 
-		JMenuItem centerMenuItem = new JMenuItem("Center");
 		centerMenuItem.addActionListener(viewListener);
-		centerMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F5, 0, false));
-		centerMenuItem.setMnemonic('c');
-		viewMenu.add(centerMenuItem);
-		viewMenu.addSeparator();
-		
-		JCheckBoxMenuItem informationWindowMenuItem = new JCheckBoxMenuItem("Information Window");
 		informationWindowMenuItem.addActionListener(viewListener);
-		informationWindowMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F4, 0, false));
-		informationWindowMenuItem.setMnemonic('i');
-		informationWindowMenuItem.setState(userPrefs.getBoolean("openInformationWindow", false));
-		viewMenu.add(informationWindowMenuItem);
-
-		if (Guess.guiMode) { // use internal console
-		JCheckBoxMenuItem consoleMenuItem = new JCheckBoxMenuItem("Console");
 		consoleMenuItem.addActionListener(viewListener);
-		consoleMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F12, 0, false));
-		consoleMenuItem.setState(userPrefs.getBoolean("openConsole", true));
-		consoleMenuItem.setMnemonic('o');
-		viewMenu.add(consoleMenuItem);
-		}
-		viewMenu.addSeparator();
-		
-		JCheckBoxMenuItem fullscreenMenuItem = new JCheckBoxMenuItem("Fullscreen");
-		fullscreenMenuItem.addActionListener(viewListener);
-		fullscreenMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F11, 0, false));
-		fullscreenMenuItem.setMnemonic('f');
-		fullscreenMenuItem.setState(userPrefs.getBoolean("openFullscreen", false));
-		viewMenu.add(fullscreenMenuItem);	
+		zoomZoomMenuItem.addActionListener(viewListener);
+		zoomSpaceMenuItem.addActionListener(viewListener);
+		fullscreenMenuItem.addActionListener(viewListener);	
 	}
 	
 	private void buildFileMenu() {
Index: src/com/hp/hpl/guess/ui/DrawWindow.java
===================================================================
RCS file: /cvsroot/guess/guess/src/com/hp/hpl/guess/ui/DrawWindow.java,v
retrieving revision 1.3
diff -u -r1.3 DrawWindow.java
--- src/com/hp/hpl/guess/ui/DrawWindow.java	30 Sep 2008 11:29:18 -0000	1.3
+++ src/com/hp/hpl/guess/ui/DrawWindow.java	17 Oct 2008 14:46:32 -0000
@@ -10,6 +10,7 @@
 import com.hp.hpl.guess.freehep.*;
 import com.hp.hpl.guess.piccolo.GFrame;
 import com.hp.hpl.guess.*;
+import com.hp.hpl.guess.piccolo.util.PFixedWidthStroke;
 
 import java.sql.Types;
 import java.net.URL;
@@ -32,7 +33,7 @@
 
     private static Color myColor = Color.gray;
     
-    private static Stroke myStroke = new BasicStroke(1.0f);
+    private static Stroke myStroke = null;
 
     private static int myArrow = 0;
 
@@ -138,7 +139,12 @@
     }
 
     private DrawWindow(String title) {
-	//setLayout(new GridLayout(3,1));
+    	if (Guess.getZooming()==Guess.ZOOMING_SPACE) {
+    		myStroke = new PFixedWidthStroke(1.0f);
+    	} else {
+    		myStroke = new BasicStroke(1.0f);
+    	}
+
 	setLayout(new GridBagLayout());
 	GridBagConstraints c = new GridBagConstraints();
 
Index: src/com/hp/hpl/guess/piccolo/GuessTextNode.java
===================================================================
RCS file: /cvsroot/guess/guess/src/com/hp/hpl/guess/piccolo/GuessTextNode.java,v
retrieving revision 1.7
diff -u -r1.7 GuessTextNode.java
--- src/com/hp/hpl/guess/piccolo/GuessTextNode.java	6 Feb 2008 18:31:48 -0000	1.7
+++ src/com/hp/hpl/guess/piccolo/GuessTextNode.java	17 Oct 2008 14:46:32 -0000
@@ -1,6 +1,7 @@
 package com.hp.hpl.guess.piccolo;
 
 import edu.umd.cs.piccolo.*;
+import edu.umd.cs.piccolo.util.PBounds;
 import edu.umd.cs.piccolo.util.PPaintContext;
 import edu.umd.cs.piccolo.nodes.*;
 import edu.umd.cs.piccolox.nodes.*;
@@ -269,10 +270,19 @@
 	    setStyle(style);
 	}
 
-	borderShape.setFrame(getX()-4,
+	if (Guess.getZooming() == Guess.ZOOMING_SPACE) {
+		float scaling = (float)(1/((GFrame)VisFactory.getFactory().getDisplay()).getGCamera().getViewScale());
+		borderShape.setFrame(getX(),
+			     getY(),
+			     getWidth(),
+			     getHeight());
+		
+	} else if (Guess.getZooming() == Guess.ZOOMING_ZOOM) {
+		borderShape.setFrame(getX()-4,
 			     getY()-4,
 			     getWidth() + 8,
 			     getHeight() + 8);
+	}
 		
 	g2.fill(borderShape);
 	g2.setPaint(strokePaint);
@@ -280,11 +290,60 @@
 	g2.draw(borderShape);
     }
 
-    public void paint(PPaintContext apc) {
-	paintInternal(apc);
-	super.paint(apc);
-    }
+    float oldScaling = 0f;
+    
+	public void paint(PPaintContext context) {
 
+		paintInternal(context);
+		if (Guess.getZooming() == Guess.ZOOMING_SPACE) {
+
+			Graphics2D g2 = context.getGraphics();
+			float scaling = (float)(1/((GFrame)VisFactory.getFactory().getDisplay()).getGCamera().getViewScale());
+			Font f = g2.getFont();
+			f = f.deriveFont((float)(10*scaling));
+			g2.setFont(f);
+			g2.drawString(getLabel(),(float)(getX() + (8 * scaling)), (float)(getY() + (10 * scaling)));
+			
+
+
+			if (scaling!=oldScaling) {
+				oldScaling = scaling;
+				owner.readjustEdges();
+			}
+			
+
+			
+		} else if (Guess.getZooming() == Guess.ZOOMING_ZOOM) {
+			paintInternal(context);
+			super.paint(context);
+		}
+		
+		
+    }	
+	
+	
+	public PBounds getBoundsReference() {
+		if ((Guess.getZooming() == Guess.ZOOMING_SPACE) &&
+				(borderShape != null)) {
+			
+			PBounds newBounds = (PBounds) super.getBoundsReference().clone();
+			float scaling = (float)(1/((GFrame)VisFactory.getFactory().getDisplay()).getGCamera().getViewScale());
+			
+			
+			newBounds.setRect(
+					newBounds.getX() + ((newBounds.getWidth() - (newBounds.getWidth() * scaling))/2), 
+					newBounds.getY() + ((newBounds.getHeight() - (newBounds.getHeight() * scaling))/2),
+					newBounds.getWidth() * scaling,  
+					newBounds.getHeight() * scaling
+					);
+	
+			
+			edu.umd.cs.piccolox.handles.PHandle.DEFAULT_HANDLE_SHAPE = new Ellipse2D.Float(0f, 0f, 6 * scaling, 6 * scaling);
+			return newBounds;
+		}
+		return super.getBoundsReference();
+	}
+	
     public static int ZOOM_SIZE = 40;
 
 
Index: src/com/hp/hpl/guess/piccolo/GuessShapeNode.java
===================================================================
RCS file: /cvsroot/guess/guess/src/com/hp/hpl/guess/piccolo/GuessShapeNode.java,v
retrieving revision 1.9
diff -u -r1.9 GuessShapeNode.java
--- src/com/hp/hpl/guess/piccolo/GuessShapeNode.java	6 Feb 2008 18:31:48 -0000	1.9
+++ src/com/hp/hpl/guess/piccolo/GuessShapeNode.java	17 Oct 2008 14:46:30 -0000
@@ -1,21 +1,19 @@
 package com.hp.hpl.guess.piccolo;
 
-import edu.umd.cs.piccolo.*;
 import edu.umd.cs.piccolo.util.PPaintContext;
 import edu.umd.cs.piccolo.nodes.*;
-import edu.umd.cs.piccolox.nodes.*;
 import edu.umd.cs.piccolo.event.*;
 import edu.umd.cs.piccolo.util.*;
-import java.awt.event.*;
+
 import java.awt.*;
 import java.awt.geom.*;
 import java.util.*;
-import edu.umd.cs.piccolo.activities.*;
 
 import com.hp.hpl.guess.Guess;
 import com.hp.hpl.guess.ui.*;
 import com.hp.hpl.guess.Node;
 import com.hp.hpl.guess.piccolo.GFrame;
+import com.hp.hpl.guess.piccolo.util.PFixedWidthStroke;
 
 public class GuessShapeNode extends PPath implements GuessPNode {
     
@@ -23,6 +21,8 @@
     
     protected GFrame frame = null;
 
+    private Double strokeWidth = 1.0;
+    
     protected int style = VisFactory.RECTANGLE;
 
     public Node getOwner() {
@@ -30,48 +30,64 @@
     }
 
     public void set(String field, Object o) {
-	/*try {*/
-	if (field.equals("style")) {
-	    setStyle(((Integer)o).intValue());
-	} else if (field.equals("x")) {
-	    setLocation(((Double)o).doubleValue(),getY());
-	} else if (field.equals("y")) {
-	    setLocation(getX(),((Double)o).doubleValue());
-	} else if (field.equals("width")) {
-	    setLocation(getX(), getY(),((Double)o).doubleValue(), 
-			getHeight());
-	} else if (field.equals("height")) {
-	    setLocation(getX(), getY(),getWidth(),
-			((Double)o).doubleValue()); 
-	} else if (field.equals("label")) {
-	    //if (o == null) {
-	    //Thread.dumpStack();
-	    //}
-	    //System.out.println("class: " + o.getClass());
-	    setLabel((String)o);
-	} else if (field.equals("labelvisible")) {
-	    setLabelVisible(((Boolean)o).booleanValue());
-	} else if (field.equals("color")) {
-	    if (o instanceof Color) {
-		setPaint((Color)o);
-	    } else {
-		setPaint((Colors.getColor((String)o,(Color)getPaint())));
-	    }
-	} else if (field.equals("labelcolor")) {
-	    if (o instanceof Color) {
-		setLabelPaint((Color)o);
-	    } else {
-		setLabelPaint((Colors.getColor((String)o,(Color)getPaint())));
-	    }
-	} else if (field.equals("visible")) {
-	    setVisible(((Boolean)o).booleanValue());
-	} else if (field.equals("strokecolor")) {
-	    if (o instanceof Color) {
-		setStrokePaint((Color)o);
-	    } else {
-		setStrokePaint((Colors.getColor((String)o,(Color)getPaint())));
-	    }
-	}
+    	/*try {*/
+    	if (field.equals("style")) {
+    	    setStyle(((Integer)o).intValue());
+    	} else if (field.equals("x")) {
+    	    setLocation(((Double)o).doubleValue(),getY());
+    	} else if (field.equals("y")) {
+    	    setLocation(getX(),((Double)o).doubleValue());
+     	} else if (field.equals("width")) {
+    		// If we are in ZOOMING_SPACE, then
+    		// we need to recalculate the size
+    		if (Guess.getZooming() == Guess.ZOOMING_SPACE) {
+    			setLocation(getX(), getY(),((Double)o).doubleValue() * 
+    					(1/frame.getGCamera().getViewScale()), getHeight());
+    		} else if (Guess.getZooming() == Guess.ZOOMING_ZOOM) {
+    			setLocation(getX(), getY(),((Double)o).doubleValue(), 
+    					getHeight());
+    		}
+    	} else if (field.equals("height")) {
+    		// If we are in ZOOMING_SPACE, then
+    		// we need to recalculate the size    		
+    		if (Guess.getZooming() == Guess.ZOOMING_SPACE) {
+    		    setLocation(getX(), getY(),getWidth(),
+    					((Double)o).doubleValue()* (1/frame.getGCamera().getViewScale())); 
+    		} else if (Guess.getZooming() == Guess.ZOOMING_ZOOM) {
+    		    setLocation(getX(), getY(),getWidth(),
+    					((Double)o).doubleValue()); 
+    		}
+    	} else if (field.equals("label")) {
+    	    //if (o == null) {
+    	    //Thread.dumpStack();
+    	    //}
+    	    //System.out.println("class: " + o.getClass());
+    	    setLabel((String)o);
+    	} else if (field.equals("labelvisible")) {
+    	    setLabelVisible(((Boolean)o).booleanValue());
+    	} else if (field.equals("color")) {
+    	    if (o instanceof Color) {
+    		setPaint((Color)o);
+    	    } else {
+    		setPaint((Colors.getColor((String)o,(Color)getPaint())));
+    	    }
+    	} else if (field.equals("labelcolor")) {
+    	    if (o instanceof Color) {
+    		setLabelPaint((Color)o);
+    	    } else {
+    		setLabelPaint((Colors.getColor((String)o,(Color)getPaint())));
+    	    }
+    	} else if (field.equals("visible")) {
+    	    setVisible(((Boolean)o).booleanValue());
+    	} else if (field.equals("strokewidth")) {
+    		setStrokeWidth(((Double)o).doubleValue());
+    	} else if (field.equals("strokecolor")) {
+    	    if (o instanceof Color) {
+    		setStrokePaint((Color)o);
+    	    } else {
+    		setStrokePaint((Colors.getColor((String)o,(Color)getPaint())));
+    	    }
+    	}
 
 	if (Guess.getMTF()) 
 	    moveToFront();
@@ -112,6 +128,8 @@
 		} else {
 		    return(Colors.toString(curcolor));
 		}
+	    } else if (field.equals("strokewidth")) {
+	    return(getStrokeWidth().toString());
 	    } else if (field.equals("strokecolor")) {
 		return(Colors.toString((Color)getStrokePaint()));
 	    } else if (field.equals("visible")) {
@@ -139,13 +157,38 @@
     }
 
     public GuessShapeNode(Shape aShape, Node owner, GFrame frame, int style) {
-	super(aShape);
-	this.owner = owner;
-	this.frame = frame;
-	this.style = style;
-	this.label = owner.getName();
-	//System.out.println("Thread 1: " + Thread.currentThread().getName() + " " + owner + " " + label);
-	//setStroke(linestroke);
+		super(aShape);
+		this.owner = owner;
+		this.frame = frame;
+		this.style = style;
+		this.label = owner.getName();
+		
+	    if (Guess.getZooming() == Guess.ZOOMING_SPACE) {
+	    	setStroke(new PFixedWidthStroke(strokeWidth.floatValue()));
+	    } else {
+	    	setStroke(new BasicStroke(strokeWidth.floatValue()));
+	    }
+    }
+        
+    /**
+     * Sets the width of the border
+     * @param width stroke width
+     */
+    public void setStrokeWidth(Double width) {
+    	strokeWidth = width;
+        if (Guess.getZooming() == Guess.ZOOMING_SPACE) {
+        	setStroke(new PFixedWidthStroke((float)width.floatValue()));
+        } else {
+        	setStroke(new BasicStroke((float)width.floatValue()));
+        }
+    }
+    
+    /**
+     * Returns the width of the stroke
+     * @return stroke width
+     */
+    public Double getStrokeWidth() {
+    	return strokeWidth;
     }
 
 
@@ -205,7 +248,7 @@
 
     public void setLocation(double x1, double y1, 
 			    double width, double height) {
-
+   	
 	setBounds(x1,
 		  y1,
 		  width,
@@ -219,20 +262,29 @@
 	double w = super.getWidth();
 	double h = super.getHeight();
 
-	//System.out.println("f: " + x1 + " " + y1);
-
-	setBounds(x1,
-		  y1,
-		  w,
-		  h);
+	setBounds(x1, y1, w, h);
 
 	owner.readjustEdges();
 	notifyHullListeners();
     }
+    
+    public boolean setBounds(double x1, double y1, double w, double h) {
+		double neww = w;
+		double newh = h;
+    	if (Guess.getZooming()==Guess.ZOOMING_SPACE) {
+	    	if (frame!=null) {
+	    	neww = w * frame.getGCamera().getViewScale();
+	    	newh = h * frame.getGCamera().getViewScale();
+	    	x1 = x1 - (neww - w)/2;
+	    	y1 = y1 - (newh - h)/2;
+	    	}
+    	}
+    	
+		return super.setBounds(x1, y1, neww, newh);
+    }
 
 
     public void setSize(double width, double height) {
-	
 	double x = super.getX();
 	double y = super.getY();
 
@@ -327,9 +379,6 @@
 	}
     }
     
-    //protected static BasicStroke linestroke = new BasicStroke((float).3);
-    protected static BasicStroke linestroke = new BasicStroke((float)3);
-    
     public static String[] breakupLines(String text) { 
 	String[] toRet = null;
 	StringTokenizer st = new StringTokenizer(text,"\n");
@@ -393,13 +442,85 @@
 	    paintLabel(g2,(float)(getX() + getWidth()+2),
 		       (float)(getY() + getHeight()),f);
 	} 
-	g2.setStroke(linestroke);
+	g2.setStroke(getStroke());
     }
 
-    public void paint(PPaintContext apc) {
-	paintOverload(apc);
-	super.paint(apc);
-    }
+    
+    
+    Shape oldta = null;
+    AffineTransform atTrans = null;
+    Shape ta = null;
+    
+	public void paint(PPaintContext context) {
+		paintOverload(context);
+
+		if (Guess.getZooming() == Guess.ZOOMING_SPACE) {
+			double contextScale = context.getScale();
+			Paint p = getPaint();
+			Graphics2D g2 = context.getGraphics();
+	
+	        ta = getPathReference();
+	        
+	        // Save old coordinates
+	        Rectangle2D oldRect = ta.getBounds2D();
+	
+	        // Translate to 0
+	        atTrans = AffineTransform.getTranslateInstance(-oldRect.getCenterX(), -oldRect.getCenterY());
+			ta = atTrans.createTransformedShape(ta);
+	
+	        // do scaling
+			atTrans = AffineTransform.getScaleInstance(1 / contextScale, 1 / contextScale);
+			ta = atTrans.createTransformedShape(ta);
+	
+	        // Translate to old coordinates
+			atTrans = AffineTransform.getTranslateInstance(oldRect.getCenterX(), oldRect.getCenterY());
+			ta = atTrans.createTransformedShape(ta);
+	
+			if (p != null) {
+				g2.setPaint(p);
+				g2.fill(ta);
+			}
+	
+			if (getStroke() != null && getStrokePaint() != null) {
+				g2.setPaint(getStrokePaint());
+				g2.setStroke(getStroke());
+				g2.draw(ta);
+			}
+			
+			
+			if ((oldta==null) || 
+					((oldta.getBounds2D().getHeight()-ta.getBounds2D().getHeight())*contextScale)>1.5 ||
+					((oldta.getBounds2D().getHeight()-ta.getBounds2D().getHeight())*contextScale)<-1.5) {
+				oldta = ta;
+				owner.readjustEdges();
+			}
+		
+		} else if (Guess.getZooming() == Guess.ZOOMING_ZOOM) {
+			super.paint(context);
+		}
+
+	}
+	
+
+	public PBounds getBoundsReference() {
+		if (Guess.getZooming() == Guess.ZOOMING_SPACE) {
+		PBounds newBounds = (PBounds) super.getBoundsReference().clone();
+		Double contextScale = ((GFrame)VisFactory.getFactory().getDisplay()).getGCamera().getViewScale();
+
+		newBounds.setRect(
+				newBounds.getX() + ((newBounds.getWidth() - (newBounds.getWidth() * (1 / contextScale)))/2), 
+				newBounds.getY() + ((newBounds.getHeight() - (newBounds.getHeight() * (1 / contextScale)))/2),
+				newBounds.getWidth() * (1 / contextScale),  
+				newBounds.getHeight() * (1 / contextScale)
+				);
+		
+		edu.umd.cs.piccolox.handles.PHandle.DEFAULT_HANDLE_SHAPE = new Ellipse2D.Float(0f, 0f, 6 * (float)(1/contextScale), 6 * (float)(1/contextScale));
+	
+		return newBounds;
+		} else {
+			return super.getBoundsReference();
+		}
+	}
 
     public double getDrawWidth() {
 	return(getWidth());
Index: src/com/hp/hpl/guess/piccolo/Arrow.java
===================================================================
RCS file: /cvsroot/guess/guess/src/com/hp/hpl/guess/piccolo/Arrow.java,v
retrieving revision 1.5
diff -u -r1.5 Arrow.java
--- src/com/hp/hpl/guess/piccolo/Arrow.java	10 Aug 2007 00:02:56 -0000	1.5
+++ src/com/hp/hpl/guess/piccolo/Arrow.java	17 Oct 2008 14:46:26 -0000
@@ -3,15 +3,18 @@
 import java.awt.*;
 import java.awt.geom.*;
 import java.util.HashMap;
+
+import com.hp.hpl.guess.piccolo.util.PFixedWidthStroke;
 import com.hp.hpl.guess.ui.VisFactory;
 
 /**
- * This pluggable utility paints either a "classic" or a "sleek" filled arrow 
- * on a given edge. To use, create an instance of the Arrow object
- * with your preferred thickness, and then call 
- * arrow.drawArrow( graphics, source_x1, source_y1, dest_x, dest_y2 ) for the edge.
+ * This pluggable utility paints either a "classic" or a "sleek" filled arrow on
+ * a given edge. To use, create an instance of the Arrow object with your
+ * preferred thickness, and then call arrow.drawArrow( graphics, source_x1,
+ * source_y1, dest_x, dest_y2 ) for the edge.
  * 
- * Note that the arrow simply uses the color currently set in the graphics context.
+ * Note that the arrow simply uses the color currently set in the graphics
+ * context.
  * 
  * @author Jon Froehlich
  * @pyobj Arrow
@@ -19,119 +22,117 @@
  */
 public class Arrow {
 
-    public static final int CLASSIC = 1;
-    public static final int SLEEK   = 2;
-    
-    protected static int m_arrowLength = -1;
-    protected static int m_arrowWidth  = -1;
-       
-    /**
-     * @pyexport
-     */
-    public static void overrideArrowLength(int length) {
-	m_arrowLength = length;
-	VisFactory.getFactory().getDisplay().repaint();
-    }
-
-    /**
-     * @pyexport
-     */
-    public static void overrideArrowWidth(int width) {
-	m_arrowWidth = width;
-	VisFactory.getFactory().getDisplay().repaint();
-    }
-
-    public static double distance(Point2D p1, Point2D p2) {
-	return Math.sqrt(Math.pow(p1.getX() - p2.getX(),2) +
-			 Math.pow(p1.getY() - p2.getY(),2));
-    }
-
-    public static double getArrowLength(double x1, double y1,
-					double x2, double y2,
-					double width) {
-	int m_arrowLength = Arrow.m_arrowLength;
-	if (m_arrowLength < 0) 
-	    m_arrowLength = (int)Math.max(4,(width * 2));		
-
-	double dist = Math.sqrt(Math.pow(x1 - x2,2) +
-				Math.pow(y1 - y2,2));
-	if (m_arrowLength > (dist / 2)) {
-	    m_arrowLength = (int)(dist / 2);
-	}
-	return(m_arrowLength);
-    }
-
-    public static void drawArrow(Graphics2D g2d, 
-				 Point2D point1, 
-				 Point2D point2,
-				 int type,
-				 double width) {
-	
-	int m_arrowWidth = Arrow.m_arrowWidth;
-	if (m_arrowWidth < 0) 
-	    m_arrowWidth = (int)Math.max(2,(width * 4));
-
-	int m_arrowLength = Arrow.m_arrowLength;
-	if (m_arrowLength < 0) 
-	    m_arrowLength = (int)Math.max(4,(width * 2));		
-
-	double dist = distance(point1,point2);
-	if (m_arrowLength > (dist / 2)) {
-	    m_arrowLength = (int)(dist / 2);
-	}
-
-	// get angle of line from 0 - 360
-	double thetaRadians = 
-	    Math.atan2(( point1.getY() - point2.getY()),
-		       (point1.getX() - point2.getX()))+
-	    Math.PI;
-	
-	AffineTransform at = new AffineTransform();
-	at.translate(point2.getX(),point2.getY());
-	at.rotate(thetaRadians);
-	Shape arrow = null;
-	if (type == SLEEK) {
-	    arrow = at.createTransformedShape(getSleekArrow(m_arrowWidth,
-							    m_arrowLength));
-	} else {
-	    arrow = at.createTransformedShape(classic);
-	}
-	g2d.fill(arrow);
-    }
-	
-    static HashMap arrowCache = new HashMap();
-
-    static GeneralPath classic = getClassicArrow();
-    
-    protected static GeneralPath getSleekArrow(int m_arrowWidth,
-					       int m_arrowLength) {
-	Dimension d = new Dimension(m_arrowWidth,m_arrowLength);
-	if (arrowCache.containsKey(d)) {
-	    return((GeneralPath)arrowCache.get(d));
-	}
-	GeneralPath arrowhead = new GeneralPath();
-	float distance = 0;
-	//		(float) point1.distance(point2)-vertexDiam/2.0f;
-	// create arrowed line general path
-	int width = (int) (m_arrowWidth/2.0f);
-	arrowhead.moveTo( 0, 0);
-	arrowhead.lineTo( (- m_arrowLength), width);
-	arrowhead.lineTo( (- m_arrowLength) , -width);
-	arrowhead.lineTo( 0, 0 );
-	arrowCache.put(d,arrowhead);
-	return arrowhead;
-    }
-    
-    protected static GeneralPath getClassicArrow(){
-	GeneralPath arrowhead = new GeneralPath();
-	//		float distance = (float) point1.distance(point2)-vertexDiam/2.0f;
-	float distance = 0;
-	// create arrowed line general path
-	int width = (int) (m_arrowWidth/2.0f);
-	arrowhead.moveTo( distance , 0);
-	arrowhead.lineTo( (distance - m_arrowLength), width);
-	arrowhead.lineTo( (distance - m_arrowLength) , -width);
-	arrowhead.lineTo( distance , 0 );
-	return arrowhead;
-    }
+	public static final int CLASSIC = 1;
+	public static final int SLEEK = 2;
+
+	protected static int m_arrowLength = -1;
+	protected static int m_arrowWidth = -1;
+
+	protected static double ARROW_WIDTH_FACTOR = 5;
+	protected static double ARROW_LENGTH_FACTOR = 3;
+
+	/**
+	 * @pyexport
+	 */
+	public static void overrideArrowLength(int length) {
+		m_arrowLength = length;
+		VisFactory.getFactory().getDisplay().repaint();
+	}
+
+	/**
+	 * @pyexport
+	 */
+	public static void overrideArrowWidth(int width) {
+		m_arrowWidth = width;
+		VisFactory.getFactory().getDisplay().repaint();
+	}
+
+	public static double distance(Point2D p1, Point2D p2) {
+		return Math.sqrt(Math.pow(p1.getX() - p2.getX(), 2)
+				+ Math.pow(p1.getY() - p2.getY(), 2));
+	}
+
+	public static double getArrowLength(double x1, double y1, double x2,
+			double y2, double width) {
+		Double m_arrowLength = width * ARROW_LENGTH_FACTOR;
+
+		double dist = Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
+		if (m_arrowLength > (dist / 2)) {
+			m_arrowLength = (Double) (dist / 2);
+		}
+		return m_arrowLength;
+	}
+
+	public static void drawArrow(Graphics2D g2d, Point2D point1,
+			Point2D point2, int type, double width) {
+
+		Double m_arrowWidth = width * ARROW_WIDTH_FACTOR;
+		Double m_arrowLength = width * ARROW_LENGTH_FACTOR;
+
+		double dist = distance(point1, point2);
+		if (m_arrowLength > (dist / 2)) {
+			m_arrowLength = (Double) (dist / 2);
+		}
+
+		// get angle of line from 0 - 360
+		double thetaRadians = Math.atan2((point1.getY() - point2.getY()),
+				(point1.getX() - point2.getX()))
+				+ Math.PI;
+
+		AffineTransform at = new AffineTransform();
+		at.translate(point2.getX(), point2.getY());
+		at.rotate(thetaRadians);
+		Shape arrow = null;
+		if (type == SLEEK) {
+			arrow = at.createTransformedShape(getSleekArrow(m_arrowWidth,
+					m_arrowLength));
+		} else {
+			arrow = at.createTransformedShape(classic);
+		}
+		g2d.fill(arrow);
+	}
+
+	static HashMap<String, GeneralPath> arrowCache = new HashMap<String, GeneralPath>();
+
+	static GeneralPath classic = getClassicArrow();
+
+	protected static GeneralPath getSleekArrow(int m_arrowWidth,
+			int m_arrowLength) {
+		return getSleekArrow(Double.valueOf(m_arrowWidth), Double
+				.valueOf(m_arrowLength));
+	}
+
+	protected static GeneralPath getSleekArrow(Double m_arrowWidth,
+			Double m_arrowLength) {
+
+		String d = new String(m_arrowWidth + "," + Arrow.m_arrowLength);
+		
+		if (arrowCache.containsKey(d)) {
+			return ((GeneralPath) arrowCache.get(d));
+		}
+		
+		GeneralPath arrowhead = new GeneralPath();
+
+		// create arrowed line general path
+		double width = (m_arrowWidth / 2.0f);
+		arrowhead.moveTo(0, 0);
+		arrowhead.lineTo((-m_arrowLength), width);
+		arrowhead.lineTo((-m_arrowLength), -width);
+		arrowhead.lineTo(0, 0);
+		arrowCache.put(d, arrowhead);
+		return arrowhead;
+	}
+
+	protected static GeneralPath getClassicArrow() {
+		GeneralPath arrowhead = new GeneralPath();
+		// float distance = (float) point1.distance(point2)-vertexDiam/2.0f;
+		float distance = 0;
+		// create arrowed line general path
+		double width = (m_arrowWidth / 2.0f);
+		arrowhead.moveTo(distance, 0);
+		arrowhead.lineTo((distance - m_arrowLength), width);
+		arrowhead.lineTo((distance - m_arrowLength), -width);
+		arrowhead.lineTo(distance, 0);
+		return arrowhead;
+	}
 }
Index: src/com/hp/hpl/guess/piccolo/GuessShapeNode3D.java
===================================================================
RCS file: /cvsroot/guess/guess/src/com/hp/hpl/guess/piccolo/GuessShapeNode3D.java,v
retrieving revision 1.5
diff -u -r1.5 GuessShapeNode3D.java
--- src/com/hp/hpl/guess/piccolo/GuessShapeNode3D.java	6 Feb 2008 18:31:48 -0000	1.5
+++ src/com/hp/hpl/guess/piccolo/GuessShapeNode3D.java	17 Oct 2008 14:46:31 -0000
@@ -1,21 +1,19 @@
 package com.hp.hpl.guess.piccolo;
 
-import edu.umd.cs.piccolo.*;
-import edu.umd.cs.piccolo.util.PPaintContext;
-import edu.umd.cs.piccolo.nodes.*;
-import edu.umd.cs.piccolox.nodes.*;
-import edu.umd.cs.piccolo.event.*;
-import edu.umd.cs.piccolo.util.*;
-import java.awt.event.*;
-import java.awt.*;
-import java.awt.geom.*;
-import java.util.*;
-import edu.umd.cs.piccolo.activities.*;
+import java.awt.Color;
+import java.awt.Font;
+import java.awt.GradientPaint;
+import java.awt.Graphics2D;
+import java.awt.Paint;
+import java.awt.Shape;
 
 import com.hp.hpl.guess.Guess;
-import com.hp.hpl.guess.ui.*;
 import com.hp.hpl.guess.Node;
-import com.hp.hpl.guess.piccolo.GFrame;
+import com.hp.hpl.guess.ui.Colors;
+import com.hp.hpl.guess.ui.StatusBar;
+import com.hp.hpl.guess.ui.VisFactory;
+
+import edu.umd.cs.piccolo.util.PPaintContext;
 
 public class GuessShapeNode3D extends GuessShapeNode {
 
@@ -181,7 +179,7 @@
 	    paintLabel(g2,(float)(getX() + getWidth()+2),
 		       (float)(getY() + getHeight()),f);
 	} 
-	g2.setStroke(linestroke);
+	g2.setStroke(getStroke());
     }
 }
     
Index: src/com/hp/hpl/guess/piccolo/GuessPEdge.java
===================================================================
RCS file: /cvsroot/guess/guess/src/com/hp/hpl/guess/piccolo/GuessPEdge.java,v
retrieving revision 1.8
diff -u -r1.8 GuessPEdge.java
--- src/com/hp/hpl/guess/piccolo/GuessPEdge.java	24 Aug 2007 00:25:13 -0000	1.8
+++ src/com/hp/hpl/guess/piccolo/GuessPEdge.java	17 Oct 2008 14:46:29 -0000
@@ -1,25 +1,21 @@
 package com.hp.hpl.guess.piccolo;
 
-import edu.umd.cs.piccolo.*;
 import edu.umd.cs.piccolo.util.PPaintContext;
 import edu.umd.cs.piccolo.nodes.*;
-import edu.umd.cs.piccolox.nodes.*;
 import edu.umd.cs.piccolo.event.*;
-import edu.umd.cs.piccolo.util.*;
-import java.awt.event.*;
 import java.awt.*;
 import java.awt.geom.*;
-import edu.umd.cs.piccolo.activities.*;
 import java.util.*;
 
 import com.hp.hpl.guess.Guess;
 import com.hp.hpl.guess.ui.*;
 import com.hp.hpl.guess.*;
 import com.hp.hpl.guess.piccolo.GFrame;
+import com.hp.hpl.guess.piccolo.util.PFixedWidthStroke;
 
 public class GuessPEdge extends PPath implements EdgeListener {
     
-    private Edge owner = null;
+	private Edge owner = null;
     
     private GFrame frame = null;
 
@@ -115,8 +111,13 @@
     }
 
     public void setLineWidth(double width) {
-	setStroke(new BasicStroke((float)width));
-	readjust();
+        if (Guess.getZooming() == Guess.ZOOMING_SPACE) {
+        	setStroke(new PFixedWidthStroke((float)width));
+        } else {
+        	setStroke(new BasicStroke((float)width));
+        }
+
+        readjust();
     }
 
     Color curcolor = Color.black;
@@ -207,7 +208,11 @@
     }
 
     public double getLineWidth() {
-	return((double)((BasicStroke)getStroke()).getLineWidth());
+    	if (getStroke() instanceof PFixedWidthStroke) {
+    		return((double)((PFixedWidthStroke)getStroke()).getLineWidth());
+    	} else {
+    		return((double)((BasicStroke)getStroke()).getLineWidth());
+    	}
     }
 
 
@@ -313,53 +318,53 @@
     }
 
     public void readjust() {
-	java.util.List l = 
-	    new java.util.ArrayList(owner.getIncidentVertices());
-	GuessPNode node1 = (GuessPNode)((Node)l.get(0)).getRep();
-	GuessPNode node2 = node1;
-	if (l.size() > 1) {
-	    node2 = (GuessPNode)((Node)l.get(1)).getRep();
-	}
-	if (node1 != node2) {
-	    if (VisFactory.getFactory().getDirected()) {
-		
-		Point2D pa = new Point2D.Double(0,0);
-		Point2D pb = new Point2D.Double(0,0);
-		findEndPoints(node1,node2,pa,pb);
-		double x1 = pa.getX();
-		double y1 = pa.getY();
-		double x2 = pb.getX();
-		double y2 = pb.getY();
-
-
-		if (VisFactory.getFactory().getDirected()) {
-		    // get angle of line from 0 - 360
-		    double cx = (x1 + x2)/2;
-		    double cy = (y1 + y2)/2;
-		    double thetaRadians = 
-			Math.atan2(( y1 - y2),
-				   (x1 - x2));
-		    double buffer = Math.max(2,
-					     Arrow.getArrowLength(x1,y1,
-								  x2,y2,
-								  getLineWidth()) / 2);
-		    //System.out.println(" " + buffer);
-
-		    double radius = (Math.sqrt(Math.pow(x1-x2,2)+
-					       Math.pow(y1-y2,2)) / 2)-buffer;
-
-		    double tx1 = radius * Math.cos(thetaRadians) + cx;
-		    double ty1 = radius * Math.sin(thetaRadians) + cy;
-
-		    thetaRadians += Math.PI;
-
-		    double tx2 = radius * Math.cos(thetaRadians) + cx;
-		    double ty2 = radius * Math.sin(thetaRadians) + cy;
-
-		    setShape(new Line2D.Double(tx1,ty1,tx2,ty2));
-		} else {
-		    setShape(new Line2D.Double(x1,y1,x2,y2));
-		}
+    	java.util.List l = 
+    	    new java.util.ArrayList(owner.getIncidentVertices());
+    	GuessPNode node1 = (GuessPNode)((Node)l.get(0)).getRep();
+    	GuessPNode node2 = node1;
+    	if (l.size() > 1) {
+    	    node2 = (GuessPNode)((Node)l.get(1)).getRep();
+    	}
+    	if (node1 != node2) {
+    	    if (VisFactory.getFactory().getDirected()) {
+    		
+    		Point2D pa = new Point2D.Double(0,0);
+    		Point2D pb = new Point2D.Double(0,0);
+    		findEndPoints(node1,node2,pa,pb);
+    		double x1 = pa.getX();
+    		double y1 = pa.getY();
+    		double x2 = pb.getX();
+    		double y2 = pb.getY();
+
+
+    		if (VisFactory.getFactory().getDirected()) {
+    		    // get angle of line from 0 - 360
+    			if (Guess.getZooming()==Guess.ZOOMING_ZOOM) {
+    		    double cx = (x1 + x2)/2;
+    		    double cy = (y1 + y2)/2;
+    		    double thetaRadians = Math.atan2(( y1 - y2), (x1 - x2));
+    		    double buffer = Math.max(2,
+    		    		Arrow.getArrowLength(x1,y1, x2,y2, getLineWidth()) / 2);
+    		    //System.out.println(" " + buffer);
+
+    		    double radius = (Math.sqrt(Math.pow(x1-x2,2)+
+    					       Math.pow(y1-y2,2)) / 2)-buffer;
+
+    		    double tx1 = radius * Math.cos(thetaRadians) + cx;
+    		    double ty1 = radius * Math.sin(thetaRadians) + cy;
+
+    		    thetaRadians += Math.PI;
+
+    		    double tx2 = radius * Math.cos(thetaRadians) + cx;
+    		    double ty2 = radius * Math.sin(thetaRadians) + cy;
+
+    		    setShape(new Line2D.Double(tx1,ty1,tx2,ty2));
+    			} else {
+    		    setShape(new Line2D.Double(x1,y1,x2,y2));
+    			}
+    		} else {
+    		    setShape(new Line2D.Double(x1,y1,x2,y2));
+    		}
 
 		if (owner instanceof DirectedEdge) {
 		    if (((Node)(((DirectedEdge)owner).getSource())).getRep() == node1) {
@@ -406,14 +411,13 @@
 		
 		// just a line, lets figure out where to place
 		// the ends
-		double lx1 = node1.getX() + 
-		    node1.getWidth() / 2;
-		double ly1 = node1.getY() + 
-		    node1.getHeight() / 2;
-		double lx2 = node2.getX() + 
-		    node2.getWidth() / 2;
-		double ly2 =  node2.getY() + 
-		    node2.getHeight() / 2;
+	    	Point2D pa = new Point2D.Double(0,0);
+			Point2D pb = new Point2D.Double(0,0);
+			findEndPoints(node1,node2,pa,pb);
+			double lx1 = pa.getX();
+			double ly1 = pa.getY();
+			double lx2 = pb.getX();
+			double ly2 = pb.getY();
 
 		setShape(new Line2D.Double(lx1,
 					   ly1,
@@ -695,13 +699,19 @@
 	    return;
 	}
 
+	
+	double arrowWidth = getLineWidth(); 
+	if (Guess.getZooming()==Guess.ZOOMING_SPACE) {
+		arrowWidth = arrowWidth * (1/frame.getGCamera().getViewScale());
+	}
+	
 	if (arrow_style == ARROW_BOTH) {
-	    Arrow.drawArrow(g2,p1,p2,Arrow.SLEEK,getLineWidth());
-	    Arrow.drawArrow(g2,p2,p1,Arrow.SLEEK,getLineWidth());
+	    Arrow.drawArrow(g2,p1,p2,Arrow.SLEEK,arrowWidth);
+	    Arrow.drawArrow(g2,p2,p1,Arrow.SLEEK,arrowWidth);
 	} else if (arrow_style == ARROW_START) {
-	    Arrow.drawArrow(g2,p2,p1,Arrow.SLEEK,getLineWidth());
+	    Arrow.drawArrow(g2,p2,p1,Arrow.SLEEK,arrowWidth);
 	} else if (arrow_style == ARROW_END) {
-	    Arrow.drawArrow(g2,p1,p2,Arrow.SLEEK,getLineWidth());
+	    Arrow.drawArrow(g2,p1,p2,Arrow.SLEEK,arrowWidth);
 	}
 
 
Index: src/com/hp/hpl/guess/piccolo/GFrame.java
===================================================================
RCS file: /cvsroot/guess/guess/src/com/hp/hpl/guess/piccolo/GFrame.java,v
retrieving revision 1.6
diff -u -r1.6 GFrame.java
--- src/com/hp/hpl/guess/piccolo/GFrame.java	6 Oct 2006 01:06:06 -0000	1.6
+++ src/com/hp/hpl/guess/piccolo/GFrame.java	17 Oct 2008 14:46:28 -0000
@@ -69,7 +69,6 @@
 	    });
     }
 
-
     public void setFrozen(boolean state) {
 	//	System.out.println("frozen: " + state);
 	this.frozen = state;
Index: src/com/hp/hpl/guess/Guess.java
===================================================================
RCS file: /cvsroot/guess/guess/src/com/hp/hpl/guess/Guess.java,v
retrieving revision 1.24
diff -u -r1.24 Guess.java
--- src/com/hp/hpl/guess/Guess.java	30 Sep 2008 11:29:19 -0000	1.24
+++ src/com/hp/hpl/guess/Guess.java	17 Oct 2008 14:46:21 -0000
@@ -6,24 +6,22 @@
 import java.awt.event.ActionListener;
 import java.awt.event.WindowAdapter;
 import java.awt.event.WindowEvent;
-import java.awt.event.WindowListener;
-
 import javax.swing.*;
 
 import java.io.*;
 import java.util.*;
 import java.util.prefs.Preferences;
 
-import com.hp.hpl.guess.*;
 import org.python.core.*;
 import org.python.util.*;
 
-import edu.uci.ics.jung.graph.*;
 import com.hp.hpl.guess.storage.*;
 import com.hp.hpl.guess.ui.*;
+
 import gnu.getopt.*;
+
+import com.hp.hpl.guess.piccolo.GFrame;
 import com.hp.hpl.guess.r.R;
-import com.hp.hpl.guess.util.GuessPyStringMap;
 import java.applet.AppletContext;
 import com.hp.hpl.guess.util.intervals.Tracker;
 
@@ -82,7 +80,7 @@
     /**
      * we also can take a list of files to execute
      */
-    private static Vector pythonToExec = null;
+    private static Vector<String> pythonToExec = null;
 
     /**
      * are we running inside an applet
@@ -118,12 +116,51 @@
      * allow multiple edges between nodes?
      */
     private static boolean multiEdge = false;
-
-    /**
+    
+	/**
      * Object to save user preferences
      */
 	private static Preferences userPrefs = Preferences.userRoot().node("/com/hp/hpl/guess");    
-    
+	
+	/**
+	 * Zooming or Spacing
+	 */
+	public static final int ZOOMING_ZOOM = 1;
+	public static final int ZOOMING_SPACE = 2;
+	private static int zoomingMode = userPrefs.getInt("zoomingMode", Guess.ZOOMING_ZOOM);
+	
+	public static void setZooming(int zoom) {
+		// Not a new zooming mode
+		if (zoom==zoomingMode) return;
+		
+		// Just for Piccolo atm
+		if ((zoom == ZOOMING_SPACE) && (VisFactory.getUIMode()!=VisFactory.PICCOLO)) {
+			System.err.println("Spacing is just implemented for Piccolo at the moment.");
+			return;
+		}
+		
+		zoomingMode = zoom;
+		
+		// Save current mode
+		userPrefs.putInt("zoomingMode", zoom);
+		
+		// Scale to 1
+		((GFrame)myF).getCamera().setViewScale(1);
+		
+		// Reinit strokes, so that a PFixedWidthStroke is
+		// used instead of BasicStroke if zoomingMode is 
+		// ZOOMING_SPACE, or the other way around if 
+		// ZOOMING_ZOOM is used.
+		interpSingleton.exec("g.edges.width = g.edges.width");
+		interpSingleton.exec("g.nodes.strokewidth = 1.5");
+		
+		// center view
+		((GFrame)myF).centerFast();
+	}
+	
+	public static int getZooming() {
+		return zoomingMode;
+	}
     /**
      * allow multiple edges
      */
@@ -222,7 +259,7 @@
      * set the frame used for synchro issues
      * @param gf the frame 
      */
-    private static void setFrame(FrameListener gf) {
+    public static void setFrame(FrameListener gf) {
 	myF = gf;
     }
 
@@ -328,7 +365,7 @@
 				  LongOpt.REQUIRED_ARGUMENT, null, 'b'); 
 	longopts[13] = new LongOpt("fitfont", 
 				   LongOpt.NO_ARGUMENT, null, 'g'); 
-
+	
 	Getopt go = new Getopt("Guess", argv, ":ptcvmofnmsl", longopts);
 	go.setOpterr(false);
 	int c;
@@ -430,7 +467,7 @@
 		(argv[i].endsWith(".Py")) ||
 		(argv[i].endsWith(".PY"))) {
 		if (pythonToExec == null) {
-		    pythonToExec = new Vector();
+		    pythonToExec = new Vector<String>();
 		}
 		pythonToExec.addElement(argv[i]);
 	    } else {
@@ -934,13 +971,13 @@
 	interp.exec("nodes = g.vertices");
 	interp.exec("edges = g.edges");
 	*/
-	Iterator nodes = g.getVertices().iterator();
+	Iterator<?> nodes = g.getVertices().iterator();
 	while (nodes.hasNext())
 	    {
 		Node node = (Node)nodes.next();
 		interp.setImmutable(node.getName(), node);
 	    }
-	Enumeration en = Colors.colors.keys();
+	Enumeration<?> en = Colors.colors.keys();
 	while(en.hasMoreElements()) {
 	    String key = (String)en.nextElement();
 	    Color val = (Color)Colors.colors.get(key);
@@ -1021,7 +1058,7 @@
 	//interp.set("cs",cs);
 	//cs.setVisible(true);
 
-	Iterator fields = g.getEdgeSchema().fields();
+	Iterator<?> fields = g.getEdgeSchema().fields();
 	while (fields.hasNext())
 	{
 		Field field = (Field)fields.next();
@@ -1083,7 +1120,7 @@
 	} 
 	
 	if (pythonToExec != null) {
-	    Iterator it = pythonToExec.iterator();
+	    Iterator<?> it = pythonToExec.iterator();
 	    while(it.hasNext()) {
 		final String fl = (String)it.next();
 		try {
Index: src/com/hp/hpl/guess/db/DBServer.java
===================================================================
RCS file: /cvsroot/guess/guess/src/com/hp/hpl/guess/db/DBServer.java,v
retrieving revision 1.15
diff -u -r1.15 DBServer.java
--- src/com/hp/hpl/guess/db/DBServer.java	29 May 2008 21:22:00 -0000	1.15
+++ src/com/hp/hpl/guess/db/DBServer.java	17 Oct 2008 14:46:26 -0000
@@ -1083,7 +1083,7 @@
 	    st = conn.createStatement();
 	    rs = st.executeQuery("SELECT name,label,x,y,visible,"+
 				 "color,fixed,style,width,height,"+
-				 "labelvisible,labelcolor,strokecolor,"+
+				 "labelvisible,labelcolor,strokewidth,strokecolor,"+
 				 "image,labelsize from nodes"); 
 	    
 	    Hashtable map = new Hashtable();
@@ -1093,6 +1093,7 @@
 		double y = rs.getDouble("y");
 		String color = rs.getString("color");
 		String labelcolor = rs.getString("labelcolor");
+		double strokewidth = rs.getDouble("strokewidth");
 		String strokecolor = rs.getString("strokecolor");
 		boolean vis = rs.getBoolean("visible");
 		String label = rs.getString("label");
@@ -1103,6 +1104,7 @@
 		double height = rs.getDouble("height");
 		String image = rs.getString("image");
 		int labelsize = rs.getInt("labelsize");
+		
 
 		// is it in the database
 		Node n = g.getNodeByName(name);
@@ -1139,6 +1141,7 @@
 		}
 
 		n.__setattr__("color",color);
+		n.__setattr__("strokewidth", strokewidth);
 		n.__setattr__("strokecolor",strokecolor);
 		n.__setattr__("fixed",new Boolean(fixed));
 		n.__setattr__("visible",new Boolean(vis));
@@ -1352,8 +1355,8 @@
 	nodedefs.put("y","Y DOUBLE DEFAULT 500");
 	nodedefs.put("visible","VISIBLE BOOLEAN DEFAULT true");
 	nodedefs.put("color","COLOR VARCHAR(32) DEFAULT 'cornflowerblue'");
-	nodedefs.put("strokecolor",
-		     "STROKECOLOR VARCHAR(32) DEFAULT 'cadetblue'");
+	nodedefs.put("strokewidth", "STROKEWIDTH DOUBLE DEFAULT 1");
+	nodedefs.put("strokecolor","STROKECOLOR VARCHAR(32) DEFAULT 'cadetblue'");
 	nodedefs.put("labelcolor","LABELCOLOR VARCHAR(32) DEFAULT NULL");
 	nodedefs.put("fixed","FIXED BOOLEAN DEFAULT false");
 	nodedefs.put("style","STYLE TINYINT DEFAULT 2");
@@ -1430,6 +1433,9 @@
 	db.alter("color",
 	      "ALTER TABLE nodes"+
 	      " ADD COLUMN color VARCHAR(32) default 'cornflowerblue'");
+	db.alter("strokewidth",
+		      "ALTER TABLE nodes"+
+		      " ADD COLUMN strokewidth DOUBLE default 1");	
 	db.alter("strokecolor",
 	      "ALTER TABLE nodes"+
 	      " ADD COLUMN strokecolor VARCHAR(32) default 'cadetblue'");
@@ -1485,6 +1491,9 @@
 	db.alter("color",
 	      "ALTER TABLE nodes_def"+
 	      " ADD COLUMN color VARCHAR(32) default 'cornflowerblue'");
+	db.alter("strokewidth",
+		      "ALTER TABLE nodes_def"+
+		      " ADD COLUMN strokewidth DOUBLE default 1");	
 	db.alter("strokecolor",
 	      "ALTER TABLE nodes_def"+
 	      " ADD COLUMN strokecolor VARCHAR(32) default 'cadetblue'");
Index: src/com/hp/hpl/guess/piccolo/util/PFixedWidthStroke.java
===================================================================
RCS file: src/com/hp/hpl/guess/piccolo/util/PFixedWidthStroke.java
diff -N src/com/hp/hpl/guess/piccolo/util/PFixedWidthStroke.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/com/hp/hpl/guess/piccolo/util/PFixedWidthStroke.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,242 @@
+/*
+ * Copyright (c) 2008, Piccolo2D project, http://piccolo2d.org
+ * Copyright (c) 1998-2008, University of Maryland
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this list of conditions
+ * and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice, this list of conditions
+ * and the following disclaimer in the documentation and/or other materials provided with the
+ * distribution.
+ *
+ * None of the name of the University of Maryland, the name of the Piccolo2D project, or the names of its
+ * contributors may be used to endorse or promote products derived from this software without specific
+ * prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
+ * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package com.hp.hpl.guess.piccolo.util;
+
+import java.awt.BasicStroke;
+import java.awt.Shape;
+import java.awt.Stroke;
+
+import java.io.Serializable;
+
+import edu.umd.cs.piccolo.util.PDebug;
+import edu.umd.cs.piccolo.util.PPaintContext;
+import edu.umd.cs.piccolo.util.PPickPath;
+
+/**
+ * <b>PFixedWidthStroke</b> is the same as {@link java.awt.BasicStroke} except
+ * that PFixedWidthStroke has a fixed width on the screen so that even when the
+ * canvas view is zooming its width stays the same in canvas coordinates. Note
+ * that this stroke draws in the inside of the stroked shape, instead of the
+ * normal draw on center behavior.
+ * <P>
+ * 
+ * @see edu.umd.cs.piccolo.nodes.PPath
+ * @version 1.0
+ * @author Jesse Grosjean
+ */
+public class PFixedWidthStroke implements Stroke, Serializable {
+
+	private static final long serialVersionUID = -7852350520291227780L;
+	
+    final static int JOIN_MITER = BasicStroke.JOIN_MITER;
+    final static int JOIN_ROUND = BasicStroke.JOIN_ROUND;
+    final static int JOIN_BEVEL = BasicStroke.JOIN_BEVEL;
+    final static int CAP_BUTT = BasicStroke.CAP_BUTT;
+    final static int CAP_ROUND = BasicStroke.CAP_ROUND;
+    final static int CAP_SQUARE = BasicStroke.CAP_SQUARE;
+
+    private float width;
+    private int join;
+    private int cap;
+    private float miterlimit;
+    private float dash[];
+    private float dash_phase;
+    
+    private BasicStroke bs = null;
+    
+    public PFixedWidthStroke() {
+        this(1.0f, CAP_SQUARE, JOIN_MITER, 10.0f, null, 0.0f);
+    }
+
+    public PFixedWidthStroke(float width) {
+        this(width, CAP_SQUARE, JOIN_MITER, 10.0f, null, 0.0f);
+    }
+
+    public PFixedWidthStroke(float width, int cap, int join) {
+        this(width, cap, join, 10.0f, null, 0.0f);
+    }
+
+    public PFixedWidthStroke(float width, int cap, int join, float miterlimit) {
+        this(width, cap, join, miterlimit, null, 0.0f);
+    }
+
+    public PFixedWidthStroke(float width, int cap, int join, float miterlimit, float dash[], float dash_phase) {
+        if (width < 0.0f) {
+            throw new IllegalArgumentException("negative width");
+        }
+        if (cap != CAP_BUTT && cap != CAP_ROUND && cap != CAP_SQUARE) {
+            throw new IllegalArgumentException("illegal end cap value");
+        }
+        if (join == JOIN_MITER) {
+            if (miterlimit < 1.0f) {
+                throw new IllegalArgumentException("miter limit < 1");
+            }
+        }
+        else if (join != JOIN_ROUND && join != JOIN_BEVEL) {
+            throw new IllegalArgumentException("illegal line join value");
+        }
+        if (dash != null) {
+            if (dash_phase < 0.0f) {
+                throw new IllegalArgumentException("negative dash phase");
+            }
+            boolean allzero = true;
+            for (int i = 0; i < dash.length; i++) {
+                float d = dash[i];
+                if (d > 0.0) {
+                    allzero = false;
+                }
+                else if (d < 0.0) {
+                    throw new IllegalArgumentException("negative dash length");
+                }
+            }
+
+            if (allzero) {
+                throw new IllegalArgumentException("dash lengths all zero");
+            }
+        }
+        this.width = width;
+        this.cap = cap;
+        this.join = join;
+        this.miterlimit = miterlimit;
+        if (dash != null) {
+            this.dash = (float[]) dash.clone();
+        }
+        this.dash_phase = dash_phase;
+    }
+
+    public Object clone() {
+        try {
+            return super.clone();
+        }
+        catch (CloneNotSupportedException e) {
+            e.printStackTrace();
+        }
+        return null;
+    }
+
+    public Shape createStrokedShape(Shape s) {
+        float fixedScale = 1.0f;
+
+        if (PDebug.getProcessingOutput()) {
+            if (PPaintContext.CURRENT_PAINT_CONTEXT != null) {
+                fixedScale = 1.0f / (float) PPaintContext.CURRENT_PAINT_CONTEXT.getScale();
+            }
+        }
+        else {
+            if (PPickPath.CURRENT_PICK_PATH != null) {
+                fixedScale = 1.0f / (float) PPickPath.CURRENT_PICK_PATH.getScale();
+            }
+        }
+        float fixedWidth = width * fixedScale;
+
+        bs = new BasicStroke(fixedWidth);
+        return bs.createStrokedShape(s);
+    }
+
+
+    public boolean equals(Object obj) {
+        if (!(obj instanceof PFixedWidthStroke)) {
+            return false;
+        }
+
+        PFixedWidthStroke bs = (PFixedWidthStroke) obj;
+        if (width != bs.width) {
+            return false;
+        }
+
+        if (join != bs.join) {
+            return false;
+        }
+
+        if (cap != bs.cap) {
+            return false;
+        }
+
+        if (miterlimit != bs.miterlimit) {
+            return false;
+        }
+
+        if (dash != null) {
+            if (dash_phase != bs.dash_phase) {
+                return false;
+            }
+
+            if (!java.util.Arrays.equals(dash, bs.dash)) {
+                return false;
+            }
+        }
+        else if (bs.dash != null) {
+            return false;
+        }
+
+        return true;
+    }
+
+    public float[] getDashArray() {
+        if (dash == null) {
+            return null;
+        }
+
+        return (float[]) dash.clone();
+    }
+
+    public float getDashPhase() {
+        return dash_phase;
+    }
+
+    public int getEndCap() {
+        return cap;
+    }
+
+    public int getLineJoin() {
+        return join;
+    }
+
+    public float getLineWidth() {
+        return width;
+    }
+
+    public float getMiterLimit() {
+        return miterlimit;
+    }
+
+    public int hashCode() {
+        int hash = Float.floatToIntBits(width);
+        hash = hash * 31 + join;
+        hash = hash * 31 + cap;
+        hash = hash * 31 + Float.floatToIntBits(miterlimit);
+        if (dash != null) {
+            hash = hash * 31 + Float.floatToIntBits(dash_phase);
+            for (int i = 0; i < dash.length; i++) {
+                hash = hash * 31 + Float.floatToIntBits(dash[i]);
+            }
+        }
+        return hash;
+    }
+}
